//
// automatically generated by spin2cpp v1.93 on Tue Aug 11 09:49:47 2015
// spin2cpp --ccode --main demo.spin 
//

//   touchpad input
// =================================================================================================
//
//   File....... jm_time.spin
//   Purpose.... Asyncrhonous (accumulator) timer
//               -- methods must be called every ~53.686s (@80MHz) or sooner to prevent error
//   Author..... Jon "JonnyMac" McPhalen
//               Copyright (c) 2014-2015 Jon McPhalen
//               -- see below for terms of use
//   E-mail..... jon@jonmcphalen.com
//   Started.... 
//   Updated.... 27 JUN 2015
//               -- startx() does not clear hold state
//               -- updated mark() with input from Dennis Page (pre-calc'd roll-over values)
//
// =================================================================================================
#include <propeller.h>
#include "badgetools.h"

#ifdef __GNUC__
#define INLINE__ static inline
//define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define waitcnt(n) _waitcnt(n)
#define coginit(id, code, par) _coginit((unsigned)(par)>>2, (unsigned)(code)>>2, id)
#define cognew(code, par) coginit(0x8, (code), (par))
#define cogstop(i) _cogstop(i)
#endif

jm_time badgeTime;
jm_time *self;

static uint8_t timedat[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};
// tix delta for rollover      
int32_t jm_time_start(void)
{
  // start now
  // Start or restart the timer object
  return jm_time_startx(CNT);
}

int32_t jm_time_startx(int32_t now)
{
  // updated 27 JUL 2015        
  // Start the timer object with specific sync point                
  // -- for synchronizing with another timer
  // set sync point
  self = &badgeTime;
  self->sync = now;
  // set ticks/microsecond
  ((int32_t *)&timedat[0])[0] = CLKFREQ / 1000000;
  // set ticks/millisecond
  ((int32_t *)&timedat[4])[0] = CLKFREQ / 1000;
  // millis in posx
  ((int32_t *)&timedat[8])[0] = 2147483647 / (*(int32_t *)&timedat[4]);
  // delta correction for rollover
  ((int32_t *)&timedat[12])[0] = (2147483647 + (2147483647 % (*(int32_t *)&timedat[4]))) + 2;
  // clear msecs, rawtix { no longer clears hold }
  memset( (void *)&self->msecs, 0, sizeof(int32_t)*2);
  return self->sync;
}

int32_t jm_time_set(int32_t ms)
{
  // Sets the timer with ms milliseconds
  // -- hold state is maintained
  jm_time_startx(CNT);
  self->msecs = ms;
  return 0;
}

int32_t jm_time_set_secs(int32_t secs)
{
  // added 30 JUN 2015
  // Sets the timer with s seconds
  // -- hold state is maintained
  jm_time_startx(CNT);
  self->msecs = secs * 1000;
  return 0;
}

int32_t jm_time_millis(void)
{
  // return milliseconds
  // Returns milliseconds accumulator
  return jm_time_mark();
}

int32_t jm_time_seconds(void)
{
  // return seconds
  // Returns seconds (from ms accumulator)                          
  return (jm_time_mark() / 1000);
}

int32_t jm_time_adjust(int32_t ms)
{
  // Adjust milliseconds register
  jm_time_mark();
  self->msecs = self->msecs + ms;
  return 0;
}

int32_t jm_time_adjust_secs(int32_t secs)
{
  // added 26 MAY 2015
  // Adjust ms register by seconds
  jm_time_mark();
  self->msecs = self->msecs + (secs * 1000);
  return 0;
}

int32_t jm_time_mark(void)
{
  int32_t	now, delta;
  // updated 31 MAY 2015  
  // Marks the current point
  // -- updates ticks and ms accumulators
  // -- returns current milliseconds
  if (self->holdstate) {
    //  do not update ms
    // if held
    return self->msecs;
  }
  // capture cnt
  now = CNT;
  // delta since last capture
  delta = now - self->sync;
  // Note on correction when delta is negative                     
  // -- NEGX (2^31) == POSX+1                                    
  // -- POSX is used twice in delta correction, hence the +2       
  if (delta < 0) {
    // rollover past posx?
    /*  posx / mstix  */
    // add posx millis
    self->msecs = self->msecs + (*(int32_t *)&timedat[8]);
    /*  posx + (posx // mstix) + 2  */
    // correct delta
    delta = delta + (*(int32_t *)&timedat[12]);
  }
  // increment ticks
  self->rawtix = self->rawtix + delta;
  // update millis
  self->msecs = self->msecs + (self->rawtix / (*(int32_t *)&timedat[4]));
  // udpate ticks    
  self->rawtix = self->rawtix % (*(int32_t *)&timedat[4]);
  // reset sync point
  self->sync = now;
  // return millis
  return self->msecs;
}

int32_t jm_time_sync_point(void)
{
  // renamed 26 APR 2015 
  // Returns sync point
  // -- used to syncronize multiple timers
  if (self->holdstate) {
    // sync not valid if on hold
    return CNT;
  } else {
    return self->sync;
  }
}

int32_t jm_time_hold(void)
{
  // added 26 APR 2015
  // Puts timer in hold state
  // -- msecs frozen at present time
  self->holdstate = -1;
  return 0;
}

int32_t jm_time_release(void)
{
  // added 26 APR 2015 
  // Releases timer to run with mark(ed) methods
  self->sync = CNT;
  // clear rawtix, holdstate
  memset( (void *)&self->rawtix, 0, sizeof(int32_t)*2);
  return 0;
}

int32_t jm_time_on_hold(void)
{
  // added 26 APR 2015 
  // Returns true when timer is in hold state
  return self->holdstate;
}

int32_t jm_time_pause(int32_t ms)
{
  int32_t	t;
  // Pause ms milliseconds
  // -- must be positive!
  // sync with overhead correction
  t = CNT - 1168;
  {
    int32_t _idx__0028;
    int32_t _limit__0029 = ms;
    for(_idx__0028 = 0; _idx__0028 < _limit__0029; _idx__0028++) {
      // wait 1ms
      waitcnt((t = t + (*(int32_t *)&timedat[4])));
    }
  }
  return 0;
}

int32_t jm_time_pause_us(int32_t us)
{
  // Pause us microseconds
  // -- must be positive, minimum of ~50us (@80MHz)
  // -- if too low, program will hang
  waitcnt(((CNT + (us * (*(int32_t *)&timedat[0]))) - 992));
  return 0;
}

/* 

  Copyright (C) 2015 Jon McPhalen 

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */
